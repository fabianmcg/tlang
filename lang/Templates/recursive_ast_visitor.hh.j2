#ifndef __RECURSIVE_AST_VISITOR_HH__
#define __RECURSIVE_AST_VISITOR_HH__
#include <deque>
#include "ast_nodes.hh"
#include "add_children.hh"
namespace _astnp_ {
template <typename Derived>
class RecursiveASTVistor {
public:
  using stack_t = std::deque<ASTNode*>;
#define WALKUP_STMT(PARENT, CLASS)                          \
  auto& derived = getDerived();                             \
  if (!(derived.walkUpTo##PARENT(node->getAsPtr<PARENT>())  \
      && derived.visit##CLASS(node)))                       \
    return false;                                           \
    return true;
#define MAKE_STACK std::unique_ptr<stack_t> _stack;         \
    if (!stack) {                                           \
      _stack = std::make_unique<stack_t>();                 \
      stack = _stack.get();                                 \
    }                                                       
#define TRAVERSE_STMT(CLASS)                                \
  auto& derived = getDerived();                             \
  if (!derived.walkUpTo##CLASS(node))                       \
    return false;                                           \
  if (!derived.postVisit(node))                             \
    return false;                                           \
    MAKE_STACK                                              \
    addChildren<CLASS>(node, stack);                        \
    traverseStack(stack);                                   \
    return true;
  Derived& getDerived() {
    return *static_cast<Derived*>(this);
  }
  bool visitASTNode(ASTNode *node) {
    return true;
  }
  bool visitASTNodeList(ASTNodeList *node) {
    return true;
  }
  {{ VISIT }}bool walkUpToASTNode(ASTNode *node) {
    return getDerived().visitASTNode(node);
  }
  bool walkUpToASTNodeList(ASTNodeList *node) {
    WALKUP_STMT(ASTNode, ASTNodeList)
  }
  {{ WALK_UP }}bool traverseASTNode(ASTNode *node, stack_t *stack = nullptr) {
    return getDerived().walkUpToASTNode(node);
  }
  bool traverseASTNodeList(ASTNodeList *node, stack_t *stack = nullptr) {
    TRAVERSE_STMT(ASTNodeList)
  }
  {{ TRAVERSE }}protected:
  bool traverseStack(stack_t *stack) {
    while (!stack->empty()) {
      auto top = stack->front();
      stack->pop_front();
      if (!top)
        continue;
      if (!selectTraverse(top, stack))
        return false;
    }
    return true;
  }
  bool selectTraverse(ASTNode *node, stack_t *stack) {
    auto kind = node->classOf();
    auto &derived = getDerived();
    switch (kind) {
    case NodeClass::ASTNode:
      return derived.traverseASTNode(node, stack);
    case NodeClass::ASTNodeList:
      return derived.traverseASTNodeList(node->getAsPtr<ASTNodeList>(), stack);
    {{ TRAVERSE_CASES }}default:
      break;
    }
    return true;
  }
  bool postVisit(ASTNode* node) {
    return true;   
  }
};
}
#undef WALKUP_STMT
#undef TRAVERSE_STMT
#undef MAKE_STACK
#endif

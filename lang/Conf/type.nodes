file Type {
  node Type<Type> {
    parents: [ASTNode];
    :{
      virtual bool isSame(const Type& y) const {
        if (this == &y)
          return true;
        return false;
      }
      QualType getQual(QualType::cvr_qualifiers_t qualifiers = QualType::None) const {
        return QualType((QualType::cvr_qualifiers_t)qualifiers, (Type*)this);
      }
    }:
  };
  node QualType<Type> {
    parents: [ASTNode];
    members: [
      cvr_qualifiers qualifiers
    ];
    children: [
      Type type
    ];
    enum cvr_qualifiers {
      None = 0,
      Reference = 1,
      Const = 2
    };
    .{
      QualType(Type* type, cvr_qualifiers qualifiers = None): __qualifiers(qualifiers), __children(type) {}
    }.
    :{
      bool isSame(const QualType& y) const {
        if (__qualifiers != y.__qualifiers)
          return false;
        if (auto xt = getType())
          if (auto yt = y.getType())
            return xt->isSame(*yt);
        return false;
      }
    }:
  };
  node DependentType<Type> {
    parents: [Type];
  };
  node CType<Type> {
    parents: [DependentType];
  };
  node UnresolvedType<Type> {
    parents: [DependentType];
    members: [
      Identifier identifier
    ];
    .{
      UnresolvedType(const Identifier& identifier):
       __identifier(identifier) {
       }
    }.
  };
  node BuiltinType<Type> {
    parents: [Type];
    :{
      virtual bool isSame(const Type& y) const {
        return y.is(classOf());
      }
    }:
  };
  node BoolType<Type> {
    parents: [BuiltinType];
  };
  node StringType<Type> {
    parents: [BuiltinType];
  };
  node IntType<Type> {
    parents: [BuiltinType];
    members: [
      numeric_precision precision,
      numeric_sign sign
    ];
    enum numeric_precision {
      Default,
      P_8,
      P_16,
      P_32,
      P_64
    };
    enum numeric_sign {
      Signed,
      Unsigned
    };
    .{
      IntType(numeric_precision p, numeric_sign s): __precision(p), __sign(s) {}
    }.
    :{
      virtual bool isSame(const Type& y) const {
        if (y.is(classOf())) {
          auto & t = static_cast<IntType&>(y);
          return __sign == t.__sign && __precision == t.__precision;
        }
        return false;
      }
    }:
  };
  node FloatType<Type> {
    parents: [BuiltinType];
    members: [
      numeric_precision precision
    ];
    enum numeric_precision {
      Default,
      P_8,
      P_16,
      P_32,
      P_64,
      P_128
    };
    .{
      FloatType(numeric_precision p): __precision(p) {}
    }.
    :{
      virtual bool isSame(const Type& y) const {
        if (y.is(classOf())) {
          auto & t = static_cast<IntType&>(y);
          return __precision == t.__precision;
        }
        return false;
      }
    }:
  };
  node VariadicType<Type> {
    parents: [Type];
    children: [
      Type underlying
    ];
    :{
      virtual bool isSame(const Type& y) const {
        if (y.is(classOf()))
          return y.is(classOf());
      }
    }:
  };
  node PtrType<Type> {
    parents: [Type];
    children: [
      Type underlying
    ];
    :{
      virtual Type** getUnderlyingPtr() {
        return &(getUnderlying());
      }
    }:
  };
  node SmartPtrType<Type> {
    parents: [PtrType];
  };
  node ArrayType<Type> {
    parents: [Type];
    children: [
      Type underlying,
      list Expr layout
    ];
    :{
      ArrayType(Type* underlying, std::vector<Expr*>&& layout) : __children(underlying, std::move(layout)) {}
      virtual Type** getUnderlyingPtr() {
        return &(getUnderlying());
      }
    }:
  };
  node DefinedType<Type> {
    parents: [Type];
    members: [
      Identifier identifier,
      reference<NamedDecl> decl
    ];
    .{
      DefinedType(const Identifier& identifier, reference<NamedDecl> decl = {}):
       __identifier(identifier), __decl(decl) {
       }
      virtual bool isDependent() const {
        return false;
      }
    }.
  };
  node TagType<Type> {
    parents: [DefinedType];
    .{
      TagType(const Identifier& identifier, reference<NamedDecl> decl = {}):
       DefinedType(identifier, decl) {
       }
    }.
  };
  node StructType<Type> {
    parents: [TagType];
    .{
      StructType(const Identifier& identifier, reference<NamedDecl> decl = {}):
       TagType(identifier, decl) {
       }
    }.
  };
  node EnumType<Type> {
    parents: [TagType];
    .{
      EnumType(const Identifier& identifier, reference<NamedDecl> decl = {}):
       TagType(identifier, decl) {
       }
    }.
  };
  node TypedefType<Type> {
    parents: [DefinedType];
    .{
      TypedefType(const Identifier& identifier, reference<NamedDecl> decl = {}):
       DefinedType(identifier, decl) {
       }
    }.
  };
  node FunctionType<Type> {
    parents: [DefinedType];
    .{
      FunctionType(const Identifier& identifier, reference<NamedDecl> decl = {}):
       DefinedType(identifier, decl) {
      }
    }.
  };
};

Stmt:
                IfStmt
                        :{
                            _r = std::move(_0);
                        }:
       |        CompoundStmt
                        :{
                            _r = std::move(_0);
                        }:
       |        WhileStmt
                        :{
                            _r = std::move(_0);
                        }:
       |        ForStmt
                        :{
                            _r = std::move(_0);
                        }:
       |        LoopStmt
                        :{
                            _r = std::move(_0);
                        }:
       |        Expr ";"
                        :{
                            _r = std::move(_0);
                        }:
       |        AtomicStmt
                        :{
                            _r = std::move(_0);
                        }:
       |        let VariableList ";"
                        :{
                            _r = create<return_t, false>(DeclStmt(std::move(*_1)));
                            _r.range(_0.begin(), _1.end());
                        }:
       |        break ";"
                        :{
                            _r = create<return_t, false>(BreakStmt());
                            _r.range(_0.begin(), _1.end());
                        }:
       |        continue ";"
                        :{
                            _r = create<return_t, false>(ContinueStmt());
                            _r.range(_0.begin(), _1.end());
                        }:
       |        return Expr ";"
                        :{
                            _r = create<return_t, false>(ReturnStmt(*_1));
                            _r.range(_0.begin(), _1.end());
                        }:
       |        ContextStmt
                        :{
                            _r = std::move(_0);
                        }:
       |        ParallelStmt
                        :{
                            _r = std::move(_0);
                        }:
       |        single Stmt
                        :{
                            _r = create<return_t, false>(SingleStmt(*_1));
                            _r.range(_0.begin(), _1.end());
                        }:
       |        leading Stmt
                        :{
                            _r = create<return_t, false>(MainStmt(*_1));
                            _r.range(_0.begin(), _1.end());
                        }:
       |        SyncStmt
                        :{
                            _r = std::move(_0);
                            _r.range(_0.begin(), _0.end());
                        }:
       ;

CompoundStmt:
                "{" StmtList "}"
                        :{
                            _r = make<return_t>();
                            if (_1) {
                              auto &stmts = *_1;
                              for (auto &stmt : stmts)
                                (*_r)->addStmt(stmt);
                            }
                            _r.range(_0.begin(), _2.end());
                        }:
       ;

StmtList @<std::vector<Stmt *>>@ static ZeroOrMore:
                Stmt
                        :{
                            init(_r);
                            (*_r).push_back(*_0);
                        }:
       ;

IfStmt:
                if IfStmtH
                        :{
                            _r = std::move(_1);
                            _r.begin() = _0.begin();
                        }:
       ;

IfStmtH @<IfStmt>@:
                "(" Expr ")" Stmt ElseStmt
                        :{
                            _r = make<return_t>(false, *_1, *_3, *_4);
                            _r.end() = _4 ? _4.end() : _3.end();
                        }:
       |        constexpr "(" Expr ")" Stmt ElseStmt
                        :{
                            _r = make<return_t>(true, *_2, *_4, *_5);
                            _r.end() = _5 ? _5.end() : _4.end();
                        }:
       ;

ElseStmt @<Stmt>@:
                else Stmt
                        :{
                            _r = std::move(_1);
                            _r.range(_0.begin(), _1.end());
                        }:
       |        E
       ;

WhileStmt:
                while "(" Expr ")" Stmt
                        :{
                            _r = make<return_t>(*_2, *_4);
                            _r.range(_0.begin(), _4.end());
                        }:
       ;

ForStmt:
                for "(" RangeList ")" Stmt
                        :{
                            _r = make<return_t>(std::move(*_2), *_4);
                            _r.range(_0.begin(), _4.end());
                        }:
       ;

RangeList @<std::vector<RangeStmt*>>@ static:
                RangeStmt RangeListH
                        :{
                            init(_r);
                            (*_r).push_back(*_0);
                            if (_1) {
                              for (auto &node : (*_1))
                                (*_r).push_back(node);
                            }
                        }:
       |        E
                        :{
                            init(_r);
                        }:
       ;

RangeListH @<std::vector<RangeStmt*>>@ static ZeroOrMore:
                CommaRange
                        :{
                            init(_r);
                            (*_r).push_back(*_0);
                        }:
       ;

CommaRange @<RangeStmt>@:
                "," RangeStmt
                        :{
                            _r = std::move(_1);
                        }:
       ;

RangeStmt:
                DeclRefExpr in RangeExpr
                        :{
                            _r = make<return_t>(nullptr, *_0, *_2);
                            _r.range(_0.begin(), _2.end());
                        }:
       |        let VariableDecl in RangeExpr
                        :{
                            _r = make<return_t>(*_1, nullptr, *_3);
                            _r.range(_0.begin(), _3.end());
                        }:
       ;


VariableList @<std::vector<VariableDecl*>>@ static:
                VariableDecl VariableListH
                        :{
                            init(_r);
                            (*_r).push_back(*_0);
                            if (_1) {
                              for (auto &node : (*_1))
                                (*_r).push_back(node);
                            }
                        }:
       |        E
                        :{
                            init(_r);
                        }:
       ;

VariableListH @<std::vector<VariableDecl*>>@ static ZeroOrMore:
                CommaVariable
                        :{
                            init(_r);
                            (*_r).push_back(*_0);
                        }:
       ;

CommaVariable @<VariableDecl>@:
                "," VariableDecl
                        :{
                            _r = std::move(_1);
                        }:
       ;

ContextStmt @<ContextStmt>@:
                context ContextKind ContextOptions Stmt
                        :{
                            _r = make<return_t>(nullptr, std::move(*_1), std::move(*_2), std::move(*_3));
                            _r.range(_0.begin(), _3.end());
                        }:
       ;

ContextKind @<ContextStmt::Kind>@ static:
                "<" Identifier ">" 
                        :{ 
                           if (_1.value() == "CPU")
                             _r = make<return_t>(ContextStmt::CPU); 
                           else if (_1.value() == "GPU")
                             _r = make<return_t>(ContextStmt::GPU); 
                           else
                             _r = make<return_t>(ContextStmt::Default); 
                        }:
       |        E  :{ _r = make<return_t>(ContextStmt::Inherited); }:
       ;

ContextOptions @<List<MapStmt*>>@ static:
                "[" MapStmtList "]" :{ _r = std::move(_1); }:
       |        E  :{ _r = make<return_t>(); }:
       ;

MapStmtList @<List<MapStmt*>>@ static ZeroOrMore:
                MapStmt
                        :{
                            init(_r);
                            (*_r).push_back(*_0);
                        }:
        ;

MapStmt: map "(" Identifier ":" ExprList ")"
                        :{
                            MapStmt::Kind kind;
                            if (_2.value() == "to")
                              kind = MapStmt::to;
                            else if (_2.value() == "from")
                              kind = MapStmt::from;
                            else if (_2.value() == "to_from")
                              kind = MapStmt::toFrom;
                            else if (_2.value() == "create")
                              kind = MapStmt::create;
                            else
                              throw(std::runtime_error("Invalid map kind: " + _2.value()));
                            _r = make<return_t>(std::move(kind), std::move(*_4));
                            _r.range(_0.begin(), _5.end());
                        }:
       ;

ParallelStmt @<ParallelStmt>@:
                parallel ParallelOptions Stmt
                        :{
                            _r = make<return_t>(std::move(*_1), *_2);
                            _r.range(_0.begin(), _2.end());
                        }:
       ;

LoopStmt:
                loop ParallelOptions "(" RangeList ")" Stmt
                        :{
                            _r = make<return_t>(std::move(*_1), std::move(*_3), *_5);
                            _r.range(_0.begin(), _5.end());
                        }:
       ;

ParallelOptions @<ParallelContext>@ static:
                "[" ParallelContext "]"
                        :{
                            _r = std::move(_1);
                        }:
       |        E      :{   _r = make<return_t>(); }:
       ;

ParallelContext @<ParallelContext>@ static ZeroOrMore:
                ParallelOpts
                        :{
                            init(_r);
                            auto index = (*_0).index();
                            if (index == 0)
                              (*_r).getNoWait() = std::get<0>(*_0);
                            else if (index == 1)
                              (*_r).getMapping() = static_cast<ParallelContext::Mapping>((*_r).getMapping() | std::get<1>(*_0));
                            else if (index == 2) {
                              auto pv = std::move(std::get<2>(*_0));
                              if(pv.first == 0)
                                (*_r).getFirstPrivateVariables() = std::move(pv.second);
                              else if(pv.first == 1)
                                (*_r).getPrivateVariables() = std::move(pv.second);
                              else
                                (*_r).getSharedVariables() = std::move(pv.second);
                            }
                            else if (index == 3)
                              (*_r).getReduceList().push_back(std::move(std::get<3>(*_0)));
                            else if (index == 4)
                              (*_r).getMappedExprs().push_back(std::move(std::get<4>(*_0)));
                            else
                              (*_r).getLaunchParameters() = std::move(std::get<5>(*_0));
                        }:
       ;

ParallelOpts @<std::variant<bool, ParallelContext::Mapping, std::pair<int, List<Expr*>>, ReduceStmt*, MapStmt*, List<TupleExpr*>>>@ static:
                FirstPrivateVariables
                        :{
                            _r = create<return_t>(std::pair<int, std::vector<Expr*>>{0, std::move(*_0)});
                        }:
        |        PrivateVariables
                        :{
                            _r = create<return_t>(std::pair<int, std::vector<Expr*>>{1, std::move(*_0)});
                        }:
        |        SharedVariables
                        :{
                            _r = create<return_t>(std::pair<int, std::vector<Expr*>>{2, std::move(*_0)});
                        }:
        |        nowait
                        :{
                            _r = create<return_t>(true);
                        }:
        |        MappingKind
                        :{
                            _r = create<return_t>(std::move(*_0));
                        }:
        |        ReduceStmt
                        :{
                            _r = create<return_t>(std::move(*_0));
                        }:
        |        MapStmt
                        :{
                            _r = create<return_t>(std::move(*_0));
                        }:
        |        launch_parameters "(" TupleList ")"
                        :{
                            _r = create<return_t>(std::move(*_2));
                        }:
       ;


MappingKind @<ParallelContext::Mapping>@ static:
                Identifier
                        :{
                            init(_r);
                            if (_0.value() == "vector")
                              (*_r) = ParallelContext::Vector;
                            else if (_0.value() == "matrix")
                              (*_r) = ParallelContext::Matrix;
                            else if (_0.value() == "tensor")
                              (*_r) = ParallelContext::Tensor;
                            else if (_0.value() == "all")
                              (*_r) = ParallelContext::All;
                        }:
      ;

FirstPrivateVariables @<std::vector<Expr*>>@ static:
                firstprivate "(" ExprList ")"
                        :{
                            _r = std::move(_2);
                        }:
       ;

PrivateVariables @<std::vector<Expr*>>@ static:
                private "(" ExprList ")"
                        :{
                            _r = std::move(_2);
                        }:
       ;

SharedVariables @<std::vector<Expr*>>@ static:
                shared "(" ExprList ")"
                        :{
                            _r = std::move(_2);
                        }:
       ;

ReduceStmtList @<List<ReduceStmt*>>@ static ZeroOrMore:
                ReduceStmt
                        :{
                            init(_r);
                            (*_r).push_back(*_0);
                        }:
      ;

ReduceStmt:
                reduce "(" ReduceOperator "," ExprList ")"
                        :{
                            _r = make<return_t>(*_2, std::move(*_4));
                            _r.range(_0.begin(), _5.end());
                        }:
       ;

ReduceOperator @<ReduceStmt::Operator>@ static:
                "+"  :{ _r = make<return_t>(ReduceStmt::Plus); }:
       ;

SyncStmt:        
                sync SyncKind ";"
                        :{
                            _r = make<return_t>(nullptr, *_1);
                            _r.range(_0.begin(), _1.end());
                        }:
       ;


SyncKind @<SyncStmt::Kind>@ static:
                Identifier
                        :{
                            init(_r);
                            if (_0.value() == "vector")
                              (*_r) = SyncStmt::Vector;
                            else if (_0.value() == "matrix")
                              (*_r) = SyncStmt::Matrix;
                            else if (_0.value() == "tensor")
                              (*_r) = SyncStmt::Tensor;
                        }:
       ;

AtomicStmt:
                atomic "(" AtomicOperator "," Expr "," Expr ")" ";"
                        :{
                            _r = make<return_t>(*_2, *_4, *_6);
                            _r.range(_0.begin(), _8.end());
                        }:
       ;

AtomicOperator @<AtomicStmt::Operator>@ static:
                "+"  :{ _r = make<return_t>(AtomicStmt::Plus); }:
       |        "-"  :{ _r = make<return_t>(AtomicStmt::Minus); }:
       ;


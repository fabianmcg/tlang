Stmt:
                IfStmt         
                        :{
                            _r = std::move(_0);
                        }:
       |        CompoundStmt         
                        :{
                            _r = std::move(_0);
                        }:
       |        WhileStmt         
                        :{
                            _r = std::move(_0);
                        }:
       |        ForStmt         
                        :{
                            _r = std::move(_0);
                        }:
       |        LoopStmt         
                        :{
                            _r = std::move(_0);
                        }:
       |        Expr ";"         
                        :{
                            _r = std::move(_0);
                        }:
       |        AtomicStmt       
                        :{
                            _r = std::move(_0);
                        }:
       |        let VariableList ";"         
                        :{
                            _r = create<return_t, false>(DeclStmt(std::move(*_1)));
                            _r.range(_0.begin(), _1.end());
                        }:
       |        break ";"         
                        :{
                            _r = create<return_t, false>(BreakStmt());
                            _r.range(_0.begin(), _1.end());
                        }:
       |        continue ";"         
                        :{
                            _r = create<return_t, false>(ContinueStmt());
                            _r.range(_0.begin(), _1.end());
                        }:
       |        return Expr ";"         
                        :{
                            _r = create<return_t, false>(ReturnStmt(*_1));
                            _r.range(_0.begin(), _1.end());
                        }:
       |        ParallelStmt
                        :{
                            _r = std::move(_0);
                        }:
       |        single Stmt         
                        :{
                            _r = create<return_t, false>(SingleStmt(*_1));
                            _r.range(_0.begin(), _1.end());
                        }:
       |        leading Stmt         
                        :{
                            _r = create<return_t, false>(MainStmt(*_1));
                            _r.range(_0.begin(), _1.end());
                        }:
       |        sync ";"         
                        :{
                            _r = create<return_t, false>(SyncStmt());
                            _r.range(_0.begin(), _1.end());
                        }:
       ;

CompoundStmt:
                "{" StmtList "}"         
                        :{
                            _r = make<return_t>(_1 ? std::move(*_1) : std::vector<Stmt *>());
                            _r.range(_0.begin(), _2.end());
                        }:
       ;

StmtList @<std::vector<Stmt *>>@ static ZeroOrMore:
                Stmt         
                        :{
                            init(_r);
                            (*_r).push_back(*_0);
                        }:
       ;

IfStmt:
                if IfStmtH         
                        :{
                            _r = std::move(_1);
                            _r.begin() = _0.begin();
                        }:
       ;

IfStmtH @<IfStmt>@:
                "(" Expr ")" Stmt ElseStmt         
                        :{
                            _r = make<return_t>(false, *_1, *_3, *_4);
                            _r.end() = _4 ? _4.end() : _3.end();
                        }:
       |        constexpr "(" Expr ")" Stmt ElseStmt         
                        :{
                            _r = make<return_t>(true, *_2, *_4, *_5);
                            _r.end() = _5 ? _5.end() : _4.end();
                        }:
       ;

ElseStmt @<Stmt>@:
                else Stmt         
                        :{
                            _r = std::move(_1);
                            _r.range(_0.begin(), _1.end());
                        }:
       |        E
       ;

WhileStmt:
                while "(" Expr ")" Stmt         
                        :{
                            _r = make<return_t>(*_2, *_4);
                            _r.range(_0.begin(), _4.end());
                        }:
       ;

ForStmt:
                for "(" RangeList ")" Stmt         
                        :{
                            _r = make<return_t>(std::move(*_2), *_4);
                            _r.range(_0.begin(), _4.end());
                        }:
       ;

LoopStmt:
                loop LoopStmtOptions "(" RangeList ")" Stmt         
                        :{
                            _r = make<return_t>((*_1).second, (*_1).first, *_3, *_5);
                            _r.range(_0.begin(), _4.end());
                        }:
       ;

LoopStmtOptions @<std::pair<ReduceStmt*, bool>>@ static:
                "[" LoopReduceOptions LoopNoWaitOptions "]"
                        :{
                            _r = make<return_t>(*_1, *_2);
                            _r.range<false>(_0.begin(), _3.end());
                        }:
        |       E :{ _r = make<return_t>(); }:
       ;

LoopReduceOptions @<ReduceStmt*>@ static:
                ReduceStmt :{ _r = make<return_t>(*_0); }:
        |       E :{ _r = make<return_t>(nullptr); }:
        ;

LoopNoWaitOptions @<bool>@ static:
                nowait :{ _r = make<return_t>(true); }:
        |       E :{ _r = make<return_t>(false); }:
        ;


RangeList @<std::vector<RangeStmt*>>@ static:
                RangeStmt RangeListH         
                        :{
                            init(_r);
                            (*_r).push_back(*_0);
                            if (_1) {
                              for (auto &node : (*_1))
                                (*_r).push_back(node);
                            }
                        }:
       |        E         
                        :{
                            init(_r);
                        }:
       ;

RangeListH @<std::vector<RangeStmt*>>@ static ZeroOrMore:
                CommaRange         
                        :{
                            init(_r);
                            (*_r).push_back(*_0);
                        }:
       ;

CommaRange @<RangeStmt>@:
                "," RangeStmt         
                        :{
                            _r = std::move(_1);
                        }:
       ;

RangeStmt:
                DeclRefExpr in RangeExpr
                        :{
                            _r = make<return_t>(nullptr, *_0, *_2);
                            _r.range(_0.begin(), _2.end());
                        }:
       |        let VariableDecl in RangeExpr
                        :{
                            _r = make<return_t>(*_1, nullptr, *_3);
                            _r.range(_0.begin(), _3.end());
                        }:
       ; 


VariableList @<std::vector<VariableDecl*>>@ static:
                VariableDecl VariableListH         
                        :{
                            init(_r);
                            (*_r).push_back(*_0);
                            if (_1) {
                              for (auto &node : (*_1))
                                (*_r).push_back(node);
                            }
                        }:
       |        E         
                        :{
                            init(_r);
                        }:
       ;

VariableListH @<std::vector<VariableDecl*>>@ static ZeroOrMore:
                CommaVariable         
                        :{
                            init(_r);
                            (*_r).push_back(*_0);
                        }:
       ;

CommaVariable @<VariableDecl>@:
                "," VariableDecl         
                        :{
                            _r = std::move(_1);
                        }:
       ;

ParallelStmt @<ParallelStmt>@:
                parallel ParallelOptions Stmt
                        :{
                            _r = make<return_t>(std::move((*_1).first), std::move((*_1).second), std::move(*_2));
                            _r.range(_0.begin(), _2.end());
                        }:
       ;

ParallelOptions @<std::pair<std::vector<Expr*>, std::vector<Expr*>>>@ static:
                "[" PrivateVariables SharedVariables "]"
                        :{
                            _r = make<return_t>(std::move(*_1), std::move(*_2));
                        }:
            |    E :{ _r = make<return_t>(); }:
       ;

PrivateVariables @<std::vector<Expr*>>@ static:
                private "(" ExprList ")"
                        :{
                            _r = std::move(_2);
                        }:
       ;

SharedVariables @<std::vector<Expr*>>@ static:
                shared "(" ExprList ")"
                        :{
                            _r = std::move(_2);
                        }:
       ;

AtomicStmt:
                atomic "(" AtomicOperator "," Expr "," Expr ")" ";"
                        :{
                            _r = make<return_t>(*_2, *_4, *_6);
                            _r.range(_0.begin(), _8.end());
                        }:
       ;

AtomicOperator @<AtomicStmt::Operator>@ static:
                "+"  :{ _r = make<return_t>(AtomicStmt::Plus); }:
       ;

ReduceStmt:
                reduce "(" ReduceOperator "," ExprList ")"
                        :{
                            _r = make<return_t>(*_2, std::move(*_4));
                            _r.range(_0.begin(), _5.end());
                        }:
       ;

ReduceOperator @<ReduceStmt::Operator>@ static:
                "+"  :{ _r = make<return_t>(ReduceStmt::Plus); }:
       ;

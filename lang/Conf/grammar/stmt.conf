Stmt:
                IfStmt
                        :{
                            _r = std::move(_0);
                        }:
       |        CompoundStmt
                        :{
                            _r = std::move(_0);
                        }:
       |        WhileStmt
                        :{
                            _r = std::move(_0);
                        }:
       |        ForStmt
                        :{
                            _r = std::move(_0);
                        }:
       |        LoopStmt
                        :{
                            _r = std::move(_0);
                        }:
       |        Expr ";"
                        :{
                            _r = std::move(_0);
                        }:
       |        AtomicStmt
                        :{
                            _r = std::move(_0);
                        }:
       |        let VariableList ";"
                        :{
                            _r = create<return_t, false>(DeclStmt(std::move(*_1)));
                            _r.range(_0.begin(), _1.end());
                        }:
       |        break ";"
                        :{
                            _r = create<return_t, false>(BreakStmt());
                            _r.range(_0.begin(), _1.end());
                        }:
       |        continue ";"
                        :{
                            _r = create<return_t, false>(ContinueStmt());
                            _r.range(_0.begin(), _1.end());
                        }:
       |        return Expr ";"
                        :{
                            _r = create<return_t, false>(ReturnStmt(*_1));
                            _r.range(_0.begin(), _1.end());
                        }:
       |        ContextStmt
                        :{
                            _r = std::move(_0);
                        }:
       |        ParallelStmt
                        :{
                            _r = std::move(_0);
                        }:
       |        single Stmt
                        :{
                            _r = create<return_t, false>(SingleStmt(*_1));
                            _r.range(_0.begin(), _1.end());
                        }:
       |        leading Stmt
                        :{
                            _r = create<return_t, false>(MainStmt(*_1));
                            _r.range(_0.begin(), _1.end());
                        }:
       |        SyncStmt ";"
                        :{
                            _r = std::move(_0);
                            _r.range(_0.begin(), _1.end());
                        }:
       ;

CompoundStmt:
                "{" StmtList "}"
                        :{
                            _r = make<return_t>();
                            if (_1) {
                              auto &stmts = *_1;
                              for (auto &stmt : stmts)
                                (*_r)->addStmt(stmt);
                            }
                            _r.range(_0.begin(), _2.end());
                        }:
       ;

StmtList @<std::vector<Stmt *>>@ static ZeroOrMore:
                Stmt
                        :{
                            init(_r);
                            (*_r).push_back(*_0);
                        }:
       ;

IfStmt:
                if IfStmtH
                        :{
                            _r = std::move(_1);
                            _r.begin() = _0.begin();
                        }:
       ;

IfStmtH @<IfStmt>@:
                "(" Expr ")" Stmt ElseStmt
                        :{
                            _r = make<return_t>(false, *_1, *_3, *_4);
                            _r.end() = _4 ? _4.end() : _3.end();
                        }:
       |        constexpr "(" Expr ")" Stmt ElseStmt
                        :{
                            _r = make<return_t>(true, *_2, *_4, *_5);
                            _r.end() = _5 ? _5.end() : _4.end();
                        }:
       ;

ElseStmt @<Stmt>@:
                else Stmt
                        :{
                            _r = std::move(_1);
                            _r.range(_0.begin(), _1.end());
                        }:
       |        E
       ;

WhileStmt:
                while "(" Expr ")" Stmt
                        :{
                            _r = make<return_t>(*_2, *_4);
                            _r.range(_0.begin(), _4.end());
                        }:
       ;

ForStmt:
                for "(" RangeList ")" Stmt
                        :{
                            _r = make<return_t>(std::move(*_2), *_4);
                            _r.range(_0.begin(), _4.end());
                        }:
       ;

LoopStmt:
                loop LoopStmtOptions "(" RangeList ")" Stmt
                        :{
                            _r = make<return_t>((*_1).second, (*_1).first, std::move(*_3), *_5);
                            _r.range(_0.begin(), _4.end());
                        }:
       ;

LoopStmtOptions @<std::pair<ReduceStmt*, bool>>@ static:
                "[" LoopReduceOptions LoopNoWaitOptions "]"
                        :{
                            _r = make<return_t>(*_1, *_2);
                            _r.range<false>(_0.begin(), _3.end());
                        }:
        |       E :{ _r = make<return_t>(); }:
       ;

LoopReduceOptions @<ReduceStmt*>@ static:
                ReduceStmt :{ _r = make<return_t>(*_0); }:
        |       E :{ _r = make<return_t>(nullptr); }:
        ;

LoopNoWaitOptions @<bool>@ static:
                nowait :{ _r = make<return_t>(true); }:
        |       E :{ _r = make<return_t>(false); }:
        ;


RangeList @<std::vector<RangeStmt*>>@ static:
                RangeStmt RangeListH
                        :{
                            init(_r);
                            (*_r).push_back(*_0);
                            if (_1) {
                              for (auto &node : (*_1))
                                (*_r).push_back(node);
                            }
                        }:
       |        E
                        :{
                            init(_r);
                        }:
       ;

RangeListH @<std::vector<RangeStmt*>>@ static ZeroOrMore:
                CommaRange
                        :{
                            init(_r);
                            (*_r).push_back(*_0);
                        }:
       ;

CommaRange @<RangeStmt>@:
                "," RangeStmt
                        :{
                            _r = std::move(_1);
                        }:
       ;

RangeStmt:
                DeclRefExpr in RangeExpr
                        :{
                            _r = make<return_t>(nullptr, *_0, *_2);
                            _r.range(_0.begin(), _2.end());
                        }:
       |        let VariableDecl in RangeExpr
                        :{
                            _r = make<return_t>(*_1, nullptr, *_3);
                            _r.range(_0.begin(), _3.end());
                        }:
       ;


VariableList @<std::vector<VariableDecl*>>@ static:
                VariableDecl VariableListH
                        :{
                            init(_r);
                            (*_r).push_back(*_0);
                            if (_1) {
                              for (auto &node : (*_1))
                                (*_r).push_back(node);
                            }
                        }:
       |        E
                        :{
                            init(_r);
                        }:
       ;

VariableListH @<std::vector<VariableDecl*>>@ static ZeroOrMore:
                CommaVariable
                        :{
                            init(_r);
                            (*_r).push_back(*_0);
                        }:
       ;

CommaVariable @<VariableDecl>@:
                "," VariableDecl
                        :{
                            _r = std::move(_1);
                        }:
       ;

ContextStmt @<ContextStmt>@:
                context Identifier ContextOptions Stmt
                        :{
                            _r = make<return_t>(std::move(_1.value()), std::move(*_2), std::move(*_3));
                            _r.range(_0.begin(), _3.end());
                        }:
       ;

ContextOptions @<List<MapStmt*>>@ static:
                "[" MapStmtList "]" :{ _r = std::move(_1); }:
       |        E  :{ _r = make<return_t>(); }:
       ;

MapStmtList@<List<MapStmt*>>@ static ZeroOrMore:
                MapStmt
                        :{
                            init(_r);
                            (*_r).push_back(*_0);
                        }:
      ;

MapStmt: map "(" Identifier ":" ExprList ")"
                        :{
                            MapStmt::Kind kind;
                            if (_2.value() == "to")
                              kind = MapStmt::to;
                            else if (_2.value() == "from")
                              kind = MapStmt::from;
                            else if (_2.value() == "to_from")
                              kind = MapStmt::toFrom;
                            else if (_2.value() == "create")
                              kind = MapStmt::create;
                            else
                              throw(std::runtime_error("Invalid map kind: " + _2.value()));
                            _r = make<return_t>(std::move(kind), std::move(*_4));
                            _r.range(_0.begin(), _5.end());
                        }:
       ;

ParallelStmt @<ParallelStmt>@:
                parallel ParallelOptionsH BlockStmt Stmt
                        :{
                            if (_2) {
                                _r = create<return_t, false>(BlockStmt(ParallelStmt(std::move(std::get<0>(*_1)), std::move(std::get<1>(*_1)), std::move(std::get<2>(*_1)), std::move(std::get<3>(*_1)), std::move(*_3)), std::move(*_2)));
                                _r.range(_0.begin(), _2.end());                            
                            } else {
                                _r = make<return_t>(std::move(std::get<0>(*_1)), std::move(std::get<1>(*_1)), std::move(std::get<2>(*_1)), std::move(std::get<3>(*_1)), std::move(*_3));
                                _r.range(_0.begin(), _2.end());
                            }
                        }:
       ;

BlockStmt @<List<TupleExpr*>>@ static:
                block "[" TupleList "]"
                        :{
                            _r = std::move(_2);
                            _r.range<false>(_0.begin(), _3.end());
                        }:
       |        E
       ;

ParallelOptionsH @<std::tuple<bool, std::string, std::vector<Expr*>, std::vector<Expr*>>>@ static:
                "[" ParallelOptionsList "]"
                        :{
                            _r = std::move(_1);
                        }:
            |    E :{ _r = make<return_t>(); }:
       ;

ParallelOptionsList @<std::tuple<bool, std::string, std::vector<Expr*>, std::vector<Expr*>>>@ static ZeroOrMore:
                ParallelOptions
                        :{
                            init(_r);
                            auto index = (*_0).index();
                            if (index == 0)
                                std::get<0>(*_r) = std::get<0>(*_0);
                            else if (index == 1)
                                std::get<1>(*_r) = std::get<1>(*_0);
                            else if (index == 2) {
                              auto pv = std::move(std::get<2>(*_0));
                              if(pv.first == 0)
                                std::get<2>(*_r) = std::move(pv.second);
                              else
                                std::get<3>(*_r) = std::move(pv.second);
                            }
                        }:
       ;

ParallelOptions @<std::variant<bool, std::string, std::pair<int, std::vector<Expr*>>>>@ static:
                PrivateVariables
                        :{
                            _r = create<return_t>(std::pair<int, std::vector<Expr*>>{0, std::move(*_0)});
                        }:
        |        SharedVariables
                        :{
                            _r = create<return_t>(std::pair<int, std::vector<Expr*>>{1, std::move(*_0)});
                        }:
        |        nowait
                        :{
                            _r = create<return_t>(true);
                        }:
        |        execution_unit "(" StringLiteral ")"
                        :{
                            _r = create<return_t>(std::move(_2.value()));
                        }:
       ;

PrivateVariables @<std::vector<Expr*>>@ static:
                private "(" ExprList ")"
                        :{
                            _r = std::move(_2);
                        }:
       ;

SharedVariables @<std::vector<Expr*>>@ static:
                shared "(" ExprList ")"
                        :{
                            _r = std::move(_2);
                        }:
       ;

AtomicStmt:
                atomic "(" AtomicOperator "," Expr "," Expr ")" ";"
                        :{
                            _r = make<return_t>(*_2, *_4, *_6);
                            _r.range(_0.begin(), _8.end());
                        }:
       ;

AtomicOperator @<AtomicStmt::Operator>@ static:
                "+"  :{ _r = make<return_t>(AtomicStmt::Plus); }:
       ;

ReduceStmt:
                reduce "(" ReduceOperator "," ExprList ")"
                        :{
                            _r = make<return_t>(*_2, std::move(*_4));
                            _r.range(_0.begin(), _5.end());
                        }:
       ;

ReduceOperator @<ReduceStmt::Operator>@ static:
                "+"  :{ _r = make<return_t>(ReduceStmt::Plus); }:
       ;

SyncStmt:        
                sync SyncStmtOpts
                        :{
                            _r = make<return_t>(nullptr, *_1);
                            _r.range(_0.begin(), _1.end());
                        }:
       ;

SyncStmtOpts @<Expr>@:        
                "[" Expr "]"
                        :{
                            _r = std::move(_1);
                        }:
       |       E        :{  _r = return_t::success(nullptr); }:
       ;
                

file Stmt {
  node Stmt<Stmt> {
    parents: [ASTNode];
  };
  node CompoundStmt<Stmt> {
    parents: [Stmt];
    children: [
      list Stmt stmts
    ];
  };
  node ValueStmt<Stmt> {
    parents: [Stmt];
  };
  node DeclStmt<Stmt> {
    parents: [Stmt];
    children: [
      Decl decl
    ];
  };
  node AttributedStmt<Stmt> {
    parents: [Stmt];
    children: [
      AttrList attributes,
      Stmt stmt
    ];
  };
  node PolicyStmt<Stmt> {
    parents: [AttributedStmt];
    members: [
      reference<PolicyDecl> policy
    ];
  };
  node IfStmt<Stmt> {
    parents: [Stmt];
    members: [
      bool Constexpr
    ];
    children: [
      Expr condition,
      Stmt then,
      Stmt else
    ];
  };
  node ForStmt<Stmt> {
    parents: [AttributedStmt];
    children: [
      RangeStmt ranges,
      CompoundStmt body
    ];
  };
  node WhileStmt<Stmt> {
    parents: [Stmt];
    children: [
      Expr condition,
      CompoundStmt body
    ];
  };
  node LoopStmt<Stmt> {
    parents: [AttributedStmt];
    children: [
      RangeStmt ranges,
      CompoundStmt body
    ];
  };
  node RangeStmt<Stmt> {
    parents: [Stmt];
    children: [
      VariableDecl decl,
      DeclRefExpr variable,
      RangeExpr range
    ];
  };
  node BreakStmt<Stmt> {
    parents: [Stmt];
  };
  node ContinueStmt<Stmt> {
    parents: [Stmt];
  };
  node ReturnStmt<Stmt> {
    parents: [ValueStmt];
    children: [
      Expr return
    ];
  };
  node SyncStmt<Stmt> {
    parents: [Stmt];
  };
  node AsyncStmt<Stmt> {
    parents: [Stmt];
  };
  node ParallelStmt<Stmt> {
    parents: [Stmt];
    children: [
      Stmt stmt
    ];
  };
};
file Expr {
  .{
    #include "AST/Stmt.hh"
    #include "AST/Operators.hh"
  }.
  node Expr<Stmt, noDefault> {
    parents: [ValueStmt];
    children: [
      QualType type
    ];
    .{
      Expr(): Expr(UnresolvedType()) {}
      template <typename T, std::enable_if_t<!std::is_same_v<T, QualType>, int> = 0>
      Expr(T&& type) : __children(QualType(QualType::None, std::forward<T>(type))) {}
      Expr(QualType&& type) : __children(std::forward<QualType>(type)) {}
    }.
  };
  node LiteralExpr<Stmt> {
    parents: [Expr];
    members: [
      string value
    ];
    .{
      template <typename T>
      LiteralExpr(T&& type, std::string value) : Expr(std::forward<T>(type)), __value(value) {}
    }.
  };
  node BooleanLiteral<Stmt> {
    parents: [LiteralExpr];
  };
  node IntegerLiteral<Stmt> {
    parents: [LiteralExpr];
    .{
      IntegerLiteral(IntType&& type, std::string value) : LiteralExpr(std::forward<IntType>(type), value) {}
    }.
  };
  node FloatLiteral<Stmt> {
    parents: [LiteralExpr];
    .{
      FloatLiteral(FloatType&& type, std::string value) : LiteralExpr(std::forward<FloatType>(type), value) {}
    }.
  };
  node ComplexLiteral<Stmt> {
    parents: [LiteralExpr];
  };
  node StringLiteral<Stmt> {
    parents: [LiteralExpr];
  };
  node ThisExpr<Stmt> {
    parents: [Expr];
  };
  node ParenExpr<Stmt> {
    parents: [Expr];
    children: [
      Expr expr
    ];
    .{
      ParenExpr(std::unique_ptr<Expr>&& expr): __children(std::forward<std::unique_ptr<Expr>>(expr)) {
        if (hasExpr())
          getType<access_kind::container>() = getExpr()->getType()->clonePtr();
      }
    }.
  };
  node UnaryOperation<Stmt> {
    parents: [Expr];
    members: [
      bool postfix
    ];
    children: [
      Expr expr
    ];
  };
  node BinaryOperation<Stmt> {
    parents: [Expr];
    members: [
      OperatorKind operator
    ];
    children: [
      Expr lhs,
      Expr rhs
    ];
    .{
      BinaryOperation(OperatorKind op, std::unique_ptr<Expr>&& lhs, std::unique_ptr<Expr>&& rhs): 
        Expr(), __operator(op), __children(std::forward<std::unique_ptr<Expr>>(lhs), std::forward<std::unique_ptr<Expr>>(rhs)) {}
    }.
  };
  node DeclRefExpr<Stmt> {
    parents: [Expr];
    members: [
      Identifier identifier,
      reference<Decl> decl
    ];
    .{
      DeclRefExpr(const Identifier& identifier): Expr(), __identifier(identifier) {}
    }.
  };
  node CallExpr<Stmt> {
    parents: [Expr];
    children: [
      Expr callee,
      list Expr args
    ];
    .{
      CallExpr(std::unique_ptr<ASTNodeList>&& args): __children(nullptr, std::forward<std::unique_ptr<ASTNodeList>>(args)) {}
    }.
  };
  node CastExpr<Stmt> {
    parents: [Expr];
    children: [
      Expr expr
    ];
  };
  node ImplicitCastExpr<Stmt> {
    parents: [Expr];
    children: [
      Expr expr
    ];
  };
  node RangeExpr<Stmt> {
    parents: [Expr];
    children: [
      Expr start,
      Expr step,
      Expr stop
    ];
  };
  node AllocateExpr<Stmt> {
    parents: [Expr];
    children: [
      Expr expr
    ];
  };
  node ParallelExpr<Stmt> {
    parents: [Expr];
  };
  node DependExpr<Stmt> {
    parents: [Expr];
  };
  node ProvideExpr<Stmt> {
    parents: [Expr];
  };
};

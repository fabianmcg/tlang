file Stmt {
  .{
    #include "AST/Type.hh"
  }.
  node Stmt<Stmt> {
    parents: [ASTNode];
  };
  node CompoundStmt<Stmt> {
    parents: [Stmt];
    children: [
      list Stmt stmts
    ];
  };
  node ValueStmt<Stmt> {
    parents: [Stmt];
  };
  node DeclStmt<Stmt> {
    parents: [Stmt];
    children: [
      Decl decl
    ];
  };
  node AttributedStmt<Stmt> {
    parents: [Stmt];
    children: [
      AttrList attributes,
      Stmt stmt
    ];
  };
  node IfStmt<Stmt> {
    parents: [Stmt];
    members: [
      bool Constexpr
    ];
    children: [
      Expr condition,
      Stmt then,
      Stmt else
    ];
  };
  node ForStmt<Stmt> {
    parents: [AttributedStmt];
    children: [
      list RangeStmt ranges,
      CompoundStmt body
    ];
  };
  node WhileStmt<Stmt> {
    parents: [Stmt];
    children: [
      Expr condition,
      Stmt body
    ];
  };
  node LoopStmt<Stmt> {
    parents: [AttributedStmt];
    children: [
      list RangeStmt ranges,
      Stmt body
    ];
  };
  node RangeStmt<Stmt> {
    parents: [Stmt];
    children: [
      VariableDecl decl,
      DeclRefExpr variable,
      RangeExpr range
    ];
  };
  node BreakStmt<Stmt> {
    parents: [Stmt];
  };
  node ContinueStmt<Stmt> {
    parents: [Stmt];
  };
  node ReturnStmt<Stmt> {
    parents: [ValueStmt];
    children: [
      Expr return
    ];
  };
  node ParallelStmt<Stmt> {
    parents: [Stmt];
    children: [
      Stmt stmt
    ];
  };
  node SyncStmt<Stmt> {
    parents: [Stmt];
  };
  node SingleStmt<Stmt> {
    parents: [Stmt];
    children: [
      Stmt stmt
    ];
  };
  node MainStmt<Stmt> {
    parents: [Stmt];
    children: [
      Stmt stmt
    ];
  };
};
file Expr {
  .{
    #include "AST/Stmt.hh"
    #include "AST/Operators.hh"
  }.
  node Expr<Stmt> {
    parents: [ValueStmt];
    children: [
      static QualType type
    ];
    .{
      Expr(QualType&& type) : __children(std::forward<QualType>(type)) {}
    }.
  };
  node LiteralExpr<Stmt> {
    parents: [Expr];
    members: [
      string value
    ];
    .{
      LiteralExpr(QualType&& type, std::string value) : Expr(std::forward<QualType>(type)), __value(value) {}
    }.
  };
  node BooleanLiteral<Stmt> {
    parents: [LiteralExpr];
  };
  node IntegerLiteral<Stmt> {
    parents: [LiteralExpr];
    .{
      IntegerLiteral(QualType&& type, std::string value) : LiteralExpr(std::forward<QualType>(type), value) {}
    }.
  };
  node FloatLiteral<Stmt> {
    parents: [LiteralExpr];
    .{
      FloatLiteral(QualType&& type, std::string value) : LiteralExpr(std::forward<QualType>(type), value) {}
    }.
  };
  node ComplexLiteral<Stmt> {
    parents: [LiteralExpr];
  };
  node StringLiteral<Stmt> {
    parents: [LiteralExpr];
    .{
      StringLiteral(QualType&& type, std::string value) : LiteralExpr(std::forward<QualType>(type), value) {}
    }.
  };
  node ThisExpr<Stmt> {
    parents: [Expr];
  };
  node ParenExpr<Stmt> {
    parents: [Expr];
    children: [
      Expr expr
    ];
    .{
      ParenExpr(Expr* expr): __children(expr) {
      }
    }.
  };
  node UnaryOperation<Stmt> {
    parents: [Expr];
    members: [
      bool postfix
    ];
    children: [
      Expr expr
    ];
  };
  node BinaryOperation<Stmt> {
    parents: [Expr];
    members: [
      OperatorKind operator
    ];
    children: [
      Expr lhs,
      Expr rhs
    ];
    .{
      BinaryOperation(OperatorKind op, Expr* lhs, Expr* rhs): 
        Expr(), __operator(op), __children(lhs, rhs) {}
    }.
  };
  node DeclRefExpr<Stmt> {
    parents: [Expr];
    members: [
      Identifier identifier,
      reference<Decl> decl
    ];
    .{
      DeclRefExpr(const Identifier& identifier): Expr(), __identifier(identifier) {}
      bool isResolved() const {
        return __decl;
      }
    }.
  };
  node MemberExpr<Stmt> {
    parents: [Expr];
    children: [
      Expr owner,
      Expr member
    ];
    .{
      MemberExpr(Expr* lhs, Expr* rhs): 
        Expr(), __children(lhs, rhs) {}
    }.
  };
  node MemberRefExpr<Stmt> {
    parents: [Expr];
    members: [
      reference<Expr> owner
    ];
    children: [
      Expr member
    ];
    .{
      MemberRefExpr(reference<Expr> owner, Expr* expr):
        Expr(), __owner(owner), __children(expr) {}
    }.
  };
  node CallExpr<Stmt> {
    parents: [Expr];
    children: [
      Expr callee,
      list Expr args
    ];
    .{
      CallExpr(std::vector<Expr*>&& args):
        __children(nullptr, std::forward<std::vector<Expr*>>(args)) {}
    }.
  };
  node CCallExpr<Stmt> {
    parents: [Expr];
    members: [
      Identifier calleeIdentifier
    ];
    children: [
      list Expr args
    ];
    .{
      CCallExpr(QualType&& type, const Identifier& callee, std::vector<Expr*>&& args): 
        Expr(std::forward<QualType>(type)), __calleeIdentifier(callee), __children(std::forward<std::vector<Expr*>>(args)) {}
    }.
  };
  node CastExpr<Stmt> {
    parents: [Expr];
    children: [
      Expr expr
    ];
  };
  node ImplicitCastExpr<Stmt> {
    parents: [Expr];
    children: [
      Expr expr
    ];
  };
  node RangeExpr<Stmt> {
    parents: [Expr];
    children: [
      Expr start,
      Expr step,
      Expr stop
    ];
  };
  node AllocateExpr<Stmt> {
    parents: [Expr];
    children: [
      Expr expr
    ];
  };
};

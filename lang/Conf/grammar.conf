/* 
* Parser entry point
*/
__top__:= ModuleDecl;

/* 
* Declarations
*/

ModuleDecl:= TopLevelDeclList :{ _r = return_t::make("__unnamed__", std::move(**_0)); }:;

TopLevelDeclList @< DeclContext >@ static ZeroOrMore:= TopLevelDecl :{ _r.init(); (*_r)->add(std::move(*_0)); }:;

TopLevelDecl @< Decl >@:=
                FunctionDecl :{ _r = std::move(_0); }:
       |        VarDecl :{ _r = std::move(_0); }:
       |        StructDecl :{ _r = std::move(_0); }:
       ;

FunctionDecl:= function QualType Identifier "(" ArgumentList ")" CompoundStmt :{ _r = return_t::make(_2.value(), DeclContext()); }:;

ArgumentList @< std::list<ParDecl> >@ static:=
                ParDecl ArgumentListH
       |        E
       ;

ArgumentListH @< std::list<ParDecl> >@ static ZeroOrMore:= CommaArgument;

CommaArgument @<ParDecl>@ static:= "," ParDecl;

ParDecl:= QualType Identifier ParInit;

ParInit @< int >@ :=
                "=" Expr
       |        E
       ;

VarDecl:= QualType Identifier;

StructDecl:= struct Identifier "{" StructElementList "}" ";";

StructElementList  @< int >@ ZeroOrMore:= StructElement;

StructElement @< int >@ :=
                StructMember
       |        StructMethod
       ;

StructMember @< int >@ := QualType Identifier;

StructMethod @< int >@ := MethodDecl;

MethodDecl @< int >@ := function QualType Identifier "(" ArgumentList ")" CompoundStmt :{ _r = return_t::make(); }:;

/* 
* Statements
*/

Stmt @< int >@ :=
                IfStmt
       |        CompoundStmt
       |        ForStmt
       |        WhileStmt
       |        Expr ";"
       ;

CompoundStmt:= "{" StmtList "}";

StmtList  @< int >@  ZeroOrMore:= Stmt;

IfStmt:= if "(" Expr ")" Stmt ElseStmt;

ElseStmt @< int >@ :=
                else Stmt
       |        E
       ;

ForStmt:= for "(" RangeExpr ")" Stmt;

WhileStmt:= while "(" Expr ")" Stmt;

/* 
* Expressions
*/

Expr:=
                DeclRefExpr
       |        IntLiteral
       |        FloatLiteral
       |        "(" Expr ")"
       |        this
       ;

DeclRefExpr:= Identifier;

RangeExpr:= Expr ":" Expr ":" Expr;

/* 
* Types
*/

QualType:=
                Type QualTypeH
       |        const Type QualTypeH
       ;

QualTypeH @< int >@ :=
                "&"
       |        E
       ;

Type:= BaseType PtrType;

PtrType @< int >@ :=
                "*"
       |        E
       ;

BaseType @< int >@ :=
                BultinType
       |        Identifier
       ;

BultinType @< int >@ :=
                IntType
       |        FloatType
       |        void
       |        bool
       |        string
       ;

IntType @< int >@ :=
                int IntTypeH
       |        uint IntTypeH
       ;

IntTypeH @< int >@ :=
                "<" IntLiteral ">"
       |        E
       ;

FloatType @< int >@ := float FloatTypeH;

FloatTypeH @< int >@ :=
                "<" IntLiteral ">"
       |        E
       ;

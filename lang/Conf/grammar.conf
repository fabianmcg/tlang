/* 
* Parser entry point
*/

__top__:
                ModuleDecl
       ;

/* 
* Declarations
*/


ModuleDecl:
                TopLevelDeclList         
                        :{
                            _r = make<return_t>(NamedDecl(Decl(), "__unnamed__"), std::move(*_0));
                            ctx.set_module(*_r);
                            _r = _0.range();
                        }:
       ;

TopLevelDeclList @<DeclContext>@ static ZeroOrMore:
                TopLevelDecl         
                        :{
                            init(_r, _0.begin(), _0.end());
                            (*_r).add(*_0);
                        }:
       ;

TopLevelDecl @<Decl>@:
                FunctionDecl         
                        :{
                            _r = std::move(_0);
                        }:
       |        VariableDecl         
                        :{
                            _r = std::move(_0);
                        }:
       |        StructDecl         
                        :{
                            _r = std::move(_0);
                        }:
       ;

FunctionDecl:
                function QualType Identifier "(" ParameterList ")" CompoundStmt         
                        :{
                            _r = make<return_t>(
                                FunctorDecl(NamedDecl(Decl(), _2.value()), DeclContext(), std::move(*_1), std::move(*_4), *_6));
                            _r.range(_0.begin(), _6.end());
                        }:
       ;

ParameterList @<std::vector<ParameterDecl*>>@ static:
                ParameterDecl ParameterListH
                        :{
                            init(_r);
                            (*_r).push_back(*_0);
                            if (_1) {
                              for (auto &node : (*_1))
                                (*_r).push_back(node);
                            }
                        }:
       |        E         
                        :{
                            init(_r);
                        }:
       ;

ParameterListH @<std::vector<ParameterDecl*>>@ static ZeroOrMore:
                CommaParameter         
                        :{
                            init(_r);
                            (*_r).push_back(*_0);
                        }:
       ;

CommaParameter @<ParameterDecl>@:
                "," ParameterDecl         
                        :{
                            _r = std::move(_1);
                        }:
       ;

ParameterDecl:
                VariableDecl         
                        :{
                            _r = create<return_t>(**_0);
                            _r.range(_0.range());
                        }:
       ;

VariableDecl:
                QualType Identifier VariableInit         
                        :{
                            _r = make<return_t>(NamedDecl(Decl(), _1.value()), std::move(*_0), *_2);
                            _r.range(_0.begin(), _2 ? _2.end() : _1.end());
                        }:
       ;

VariableInit @<Expr>@:
                "=" Expr
                        :{
                           _r = std::move(_1);
                        }:
       |        E
       ;

StructDecl:
                struct Identifier "{" StructElementList "}" ";"         
                        :{
                            _r = make<return_t>(_1.value(), _3 ? std::move(*_3) : DeclContext());
                            _r.range(_0.begin(), _5.end());
                        }:
       ;

StructElementList @<DeclContext>@ static ZeroOrMore:
                StructElement         
                        :{
                            init(_r);
                            (*_r).add(*_0);
                        }:
       ;

StructElement @<Decl>@:
                MemberDecl         
                        :{
                            _r = std::move(_0);
                        }:
       |        MethodDecl         
                        :{
                            _r = std::move(_0);
                        }:
       ;

MemberDecl:
                VariableDecl         
                        :{
                            _r = create<return_t>(**_0);
                            _r.range(_0.range());
                        }:
       ;

MethodDecl:
                function QualType Identifier "(" ParameterList ")" CompoundStmt         
                        :{
                            _r = make<return_t>(
                                FunctorDecl(NamedDecl(Decl(), _2.value()), DeclContext(), std::move(*_1), std::move(*_4), *_6));
                            _r.range(_0.begin(), _6.end());
                        }:
       ;

/* 
* Statements
*/

Stmt:
                IfStmt         
                        :{
                            _r = std::move(_0);
                        }:
       |        CompoundStmt         
                        :{
                            _r = std::move(_0);
                        }:
       /*|        ForStmt         
                        :{
                            _r = std::move(_0);
                        }:*/
       |        WhileStmt         
                        :{
                            _r = std::move(_0);
                        }:
       |        Expr ";"         
                        :{
                            _r = std::move(_0);
                        }:
       |        let VariableDecl ";"         
                        :{
                            _r = create<return_t>(DeclStmt(Stmt(), *_1));
                            _r.range(_0.begin(), _1.end());
                        }:
       ;

CompoundStmt:
                "{" StmtList "}"         
                        :{
                            _r = make<return_t>(Stmt(), _1 ? std::move(*_1) : std::vector<Stmt*>());
                            _r.range(_0.begin(), _2.end());
                        }:
       ;

StmtList @<std::vector<Stmt*>>@ static ZeroOrMore:
                Stmt         
                        :{
                            init(_r);
                            (*_r).push_back(*_0);
                        }:
       ;

IfStmt:
                if IfStmtH         
                        :{
                            _r = std::move(_1);
                            _r.begin() = _0.begin();
                        }:
       ;

IfStmtH @<IfStmt>@:
                "(" Expr ")" Stmt ElseStmt         
                        :{
                            _r = make<return_t>(Stmt(), false, *_1, *_3, *_4);
                            _r.end() = _4 ? _4.end(): _3.end();
                        }:
       |        constexpr "(" Expr ")" Stmt ElseStmt         
                        :{
                            _r = make<return_t>(Stmt(), true, *_2, *_4, *_5);
                            _r.end() = _5 ? _5.end(): _4.end();
                        }:
       ;

ElseStmt @<Stmt>@:
                else Stmt         
                        :{
                            _r = std::move(_1);
                            _r.range(_0.begin(), _1.end());
                        }:
       |        E
       ;

/*ForStmt:
                for "(" RangeExpr ")" Stmt         
                        :{
                            _r = make<return_t>(Stmt(), *_2, *_4);
                        }:
       ;*/

WhileStmt:
                while "(" Expr ")" Stmt         
                        :{
                            _r = make<return_t>(Stmt(), *_2, *_4);
                            _r.range(_0.begin(), _4.end());
                        }:
       ;

/* 
* Expressions
*/

Expr: TopExpr;

TopExpr @<Expr>@:
                PrimaryExpr PostfixExpr
                        :{ 
                            if (!_1)
                                _r = std::move(_0);
                            else {
                                if (auto expr = dynamic_cast<CallExpr*>(*_1)) {
                                    expr->getCallee() = *_0;
                                    _r = std::move(_1);
                                }
                                _r.range(_0.begin(), _1.end());
                            }
                        }:
        |       CCallExpr
                        :{
                            _r = std::move(_0);
                        }:
       ;

CCallExpr:
                ccall "::" Identifier "(" ExprList ")"
                        :{
                            _r = make<return_t>(get_qualType(CType()), _2.value(), std::move(*_4));
                            _r.range(_0.begin(), _5.end());
                        }:
        ;

PrimaryExpr @<Expr>@:
                DeclRefExpr         
                        :{
                            _r = std::move(_0);
                        }:
       |        ConstantExpr         
                        :{
                            _r = std::move(_0);
                        }:
       |        "(" Expr ")"         
                        :{
                            _r = create<return_t>(ParenExpr(*_1));
                            _r.range(_0.begin(), _2.end());
                        }:
       |        this         
                        :{
                            _r;
                        }:
       ;
       
PostfixExpr @<Expr>@ Predictive:
                CallExpr         
                        :{
                            _r = std::move(_0);
                        }:
       |        ArrayExpr         
                        :{
                            _r = std::move(_0);
                        }:
       |        "++"         
                        :{
                            _r;
                        }:
       |        "--"         
                        :{
                            _r;
                        }:
       |        E
       ;

CallExpr:
                "(" ExprList ")"
                        :{
                            _r = make<return_t>(std::move(*_1));
                            _r.range(_0.begin(), _2.end());
                        }:
        ;

ExprList @<std::vector<Expr*>>@ static:
                ExprElement ExprListH
                        :{
                            init(_r);
                            (*_r).push_back(*_0);
                            if (_1) {
                              for (auto &node : (*_1))
                                (*_r).push_back(node);
                            }
                        }:
       |        E         
                        :{
                            init(_r);
                        }:
       ;

ExprListH @<std::vector<Expr*>>@ static ZeroOrMore:
                CommaListExpr         
                        :{
                            init(_r);
                            (*_r).push_back(*_0);
                        }:
       ;

CommaListExpr @<Expr>@:
                "," ExprElement         
                        :{
                            _r = std::move(_1);
                        }:
       ;

ExprElement @<Expr>@:
                Expr
                        :{
                            _r = std::move(_0);
                        }:
       ;

PrefixExpr @<Expr>@:
                "+"         
                        :{
                            _r;
                        }:
       |        "-"         
                        :{
                            _r;
                        }:
       |        "!"         
                        :{
                            _r;
                        }:
       |        "*"         
                        :{
                            _r;
                        }:
       |        "~"         
                        :{
                            _r;
                        }:
       |        "++"         
                        :{
                            _r;
                        }:
       |        "--"         
                        :{
                            _r;
                        }:
       |        E
       ;

DeclRefExpr:
                Identifier         
                        :{
                            _r = make<return_t>(_0.value());
                            _r.range() = _0.range();
                        }:
       ;

ArrayExpr @<Expr>@:
                "[" ArrayExprList "]"
       ;

ArrayExprList @<std::vector<Expr*>>@ static:
                ArrayExprElement ArrayExprListH
       ;

ArrayExprListH @<std::vector<Expr*>>@ static ZeroOrMore:
                CommaArrayExpr         
                        :{
                            init(_r);
                            (*_r).push_back(*_0);
                        }:
       ;

CommaArrayExpr @<Expr>@:
                "," ArrayExprElement         
                        :{
                            _r = std::move(_1);
                        }:
       ;

ArrayExprElement @<Expr>@:
                RangeExpr
       ;

ConstantExpr @<Expr>@:
                IntLiteral         
                        :{
                            _r = create<return_t>(IntegerLiteral(get_qualType(IntType()), _0.value()));
                            _r.range() = _0.range();
                        }:
       |        FloatLiteral         
                        :{
                            _r = create<return_t>(FloatLiteral(get_qualType(FloatType()), _0.value()));
                            _r.range() = _0.range();
                        }:
        |       StringLiteral
                        :{
                            _r = create<return_t>(StringLiteral(get_qualType(StringType()), _0.value()));
                            _r.range() = _0.range();
                        }:
       ;

RangeExpr:
                Expr ":" Expr ":" Expr
       ;

/* 
* Types
*/

QualType static:
                Type QualTypeH         
                        :{
                            _r = make<return_t>((QualType::cvr_qualifiers)(QualType::None | *_1), *_0);
                            _r.range(_0.begin(), _1 ? _1.end(): _0.end());
                        }:
       |        const Type QualTypeH         
                        :{
                            _r = make<return_t>((QualType::cvr_qualifiers)(QualType::Const | *_2), *_1);
                            _r.range(_0.begin(), _2 ? _2.end(): _1.end());
                        }:
       ;

QualTypeH @<QualType::cvr_qualifiers>@ static:
                "&"         
                        :{
                            _r = make<return_t>(QualType::Reference);
                            _r.template range<false>(_0.range());
                        }:
       |        E         
                        :{
                            _r = make<return_t>(QualType::None);
                        }:
       ;

Type:
                BaseType PtrType         
                        :{
                            if (_1) {
                              _r = make_type(PtrType(Type(), *_0));
                              _r.range(_0.begin(), _1.end());
                            }
                            else
                              _r = std::move(_0);
                        }:
       ;

PtrType @<bool>@ static:
                "*"         
                        :{
                            _r = make<return_t>(true);
                            _r.template range<false>(_0.range());
                        }:
       |        E
       ;

BaseType @<Type>@:
                BuiltinType         
                        :{
                            _r = std::move(_0);
                        }:
       |        Identifier         
                        :{
                            _r = make_type(DefinedType(Type(), _0.value(), reference<NamedDecl>{}));
                            _r.range(_0.range());
                        }:
       |        auto         
                        :{
                            _r = make_type(AutoType());
                            _r.range(_0.range());
                        }:
       ;

BuiltinType:
                IntType         
                        :{
                            _r = std::move(_0);
                        }:
       |        FloatType         
                        :{
                            _r = std::move(_0);
                        }:
       |        void         
                        :{
                            _r = make_type(VoidType());
                            _r.range(_0.range());
                        }:
       |        bool         
                        :{
                            _r = make_type(BoolType());
                            _r.range(_0.range());
                        }:
       |        string         
                        :{
                            _r = make_type(StringType());
                            _r.range(_0.range());
                        }:
       ;

IntType:
                int IntTypeH         
                        :{
                            _r = make_type(IntType(BuiltinType(), IntType::Default, IntType::Signed));
                            _r.range(_0.range());
                        }:
       |        uint IntTypeH         
                        :{
                            _r = make_type(IntType(BuiltinType(), IntType::Default, IntType::Unsigned));
                            _r.range(_0.range());
                        }:
       ;

IntTypeH @<int>@:
                "<" IntLiteral ">"
       |        E
       ;

FloatType:
                float FloatTypeH         
                        :{
                            _r = make_type(FloatType(BuiltinType(), FloatType::Default));
                            _r.range(_0.range());
                        }:
       ;

FloatTypeH @<int>@:
                "<" IntLiteral ">"
       |        E
       ;


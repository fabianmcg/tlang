/* 
* Parser entry point
*/
__top__:= ModuleDecl;

/* 
* Declarations
*/

ModuleDecl:= TopLevelDeclList :{ _r = return_t::make(NamedDecl(Decl(), "__unnamed__"), std::move(**_0)); }:;

TopLevelDeclList @< DeclContext >@ static ZeroOrMore:= TopLevelDecl :{ _r.init(); (*_r)->add(std::move(*_0)); }:;

TopLevelDecl @< Decl >@:=
                FunctionDecl :{ _r = std::move(_0); }:
       |        VariableDecl :{ _r = std::move(_0); }:
       |        StructDecl :{ _r = std::move(_0); }:
       ;

FunctionDecl:= function QualType Identifier "(" ParameterList ")" CompoundStmt 
       :{ _r = return_t::make(FunctorDecl(NamedDecl(Decl(), _2.value()), DeclContext(), std::move(*_1), std::move(*_4), std::move(*_6))); }:;

ParameterList @< ASTNodeList >@:=
                ParameterDecl ParameterListH 
                     :{     _r.init();
                            (*_r)->push_back(std::move(*_0)); 
                            if (_1.isSuccess()) {
                                   for (auto& node : (**_1) )
                                   (*_r)->push_back(std::move(node));
                            } 
                     }:
       |        E :{ _r.init(); }:
       ;

ParameterListH @< ASTNodeList >@ ZeroOrMore:= CommaParameter :{ _r.init(); (*_r)->push_back(std::move(*_0)); }:;

CommaParameter @<ParameterDecl>@:= "," ParameterDecl :{ _r = std::move(_1); }:;

ParameterDecl:= QualType Identifier ParameterInit 
       :{ _r = return_t::make(VariableDecl(NamedDecl(Decl(), _1.value()), std::move(*_0))); }:;

ParameterInit @< int >@ :=
                "=" Expr
       |        E
       ;

VariableDecl:= QualType Identifier;

StructDecl:= struct Identifier "{" StructElementList "}" ";";

StructElementList  @< int >@ ZeroOrMore:= StructElement;

StructElement @< int >@ :=
                StructMember
       |        StructMethod
       ;

StructMember @< int >@ := QualType Identifier;

StructMethod @< int >@ := MethodDecl;

MethodDecl @< int >@ := function QualType Identifier "(" ParameterList ")" CompoundStmt :{ _r = return_t::make(); }:;

/* 
* Statements
*/

Stmt @< int >@ :=
                IfStmt
       |        CompoundStmt
       |        ForStmt
       |        WhileStmt
       |        Expr ";"
       ;

CompoundStmt:= "{" StmtList "}";

StmtList  @< int >@  ZeroOrMore:= Stmt;

IfStmt:= if "(" Expr ")" Stmt ElseStmt;

ElseStmt @< int >@ :=
                else Stmt
       |        E
       ;

ForStmt:= for "(" RangeExpr ")" Stmt;

WhileStmt:= while "(" Expr ")" Stmt;

/* 
* Expressions
*/

Expr:=
                DeclRefExpr
       |        IntLiteral
       |        FloatLiteral
       |        "(" Expr ")"
       |        this
       ;

DeclRefExpr:= Identifier;

RangeExpr:= Expr ":" Expr ":" Expr;

/* 
* Types
*/

QualType:=
                Type QualTypeH :{ _r = return_t::make(ASTNode(), (QualType::cvr_qualifiers) (QualType::None | **_1), std::move(*_0)); }:
       |        const Type QualTypeH :{ _r = return_t::make(ASTNode(), (QualType::cvr_qualifiers) (QualType::Const | **_2), std::move(*_1)); }:
       ;

QualTypeH @< QualType::cvr_qualifiers >@ static :=
                "&" :{ _r = return_t::make(QualType::Reference); }:
       |        E :{ _r = return_t::make(QualType::None); }:
       ;

Type:= BaseType PtrType :{ if (_1) _r = return_t::create(PtrType(Type(), std::move(*_0))); else _r = std::move(_0); }:;

PtrType @< bool >@ static:= 
                "*" :{ _r = return_t::make(true); }:
       |        E
       ;

BaseType @< Type >@ :=
                BuiltinType :{ _r = std::move(_0); }:
       |        Identifier :{ _r = return_t::create(DefinedType(Type(), _0.value(), reference<TagDecl>{})); }:
       ;

BuiltinType:=
                IntType :{ _r = std::move(_0); }:
       |        FloatType :{ _r = std::move(_0); }:
       |        void :{ _r = return_t::create(VoidType()); }:
       |        bool :{ _r = return_t::create(BoolType()); }:
       |        string :{ _r = return_t::create(StringType()); }:
       ;

IntType:=
                int IntTypeH :{ _r = return_t::make(IntType(BuiltinType(), IntType::Default, IntType::Signed)); }:
       |        uint IntTypeH :{ _r = return_t::make(IntType(BuiltinType(), IntType::Default, IntType::Unsigned)); }:
       ;

IntTypeH @< int >@ :=
                "<" IntLiteral ">"
       |        E
       ;

FloatType:= float FloatTypeH :{ _r = return_t::make(FloatType(BuiltinType(), FloatType::Default)); }:;

FloatTypeH @< int >@ :=
                "<" IntLiteral ">"
       |        E
       ;
